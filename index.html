<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <title>layui</title>
    <meta name="renderer" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <link rel="stylesheet" href="./index.css">
    </link>

  </head>

  <body>
    <main id="app">
      <section id="eli-app" ref="eliApp" @mousedown.stop.prevent="mouseDown">
        <div v-for="(item, index) in eliData" :key="index" class="row" :class="'row-' + index">
          <div v-for="(item1, index1) in item" :key="index1" class="col" :class="'col-' + index1"
            :class="'col-' +index+'-'+ index1">
            <div class="drag-item" :class="'div-' + item1" :ref="setItemRef('i-'+index+'-'+index1)">
              {{item1}}
            </div>
          </div>
        </div>
      </section>
      <button @click="shuffle">洗牌</button>
    </main>


    <script type="module">
      import { createApp, ref, nextTick, reactive } from './vue.esm-browser.js'
      import Elimination from './elimination.js'
      let elimination = new Elimination(36, 10)
      let target = null
      let startMousePosition = [] //开始鼠标位置
      createApp(
        {
          setup() {
            let eliData = ref([])
            let eliApp = ref(null)
            let balckSideLength = ref(0)//小块的宽度   就是css的--side-length
            let offsetData = ref({
              start: [],
              end: [],
            })//元素的最小坐标 和最大坐标
            let itemRefs = ref({}); // 创建一个 refs 对象来存储 DOM 元素的引用
            return {
              eliData, eliApp, itemRefs, offsetData
            }
          },
          created() {
            this.getTwoDimensionalArrData()
          },
          mounted() {
            this.offsetData.start = [this.eliApp.offsetLeft, this.eliApp.offsetTop]
            this.offsetData.end = [this.eliApp.offsetLeft + this.eliApp.offsetWidth, this.eliApp.offsetTop + this.eliApp.offsetHeight]
            this.balckSideLength = this.itemRefs['i-0-0'].offsetWidth//获取第一个小块的宽度
          },

          methods: {
            //获取二维数组数据
            getTwoDimensionalArrData() {
              this.eliData = elimination.getTwoDimensionalArr()
            },
            //洗牌
            shuffle() {
              console.log('洗牌')
              elimination.updataShuffle()
              this.getTwoDimensionalArrData()
            },
            // 设置 ref 的函数
            setItemRef(id) {
              return (el) => {
                if (el) {
                  this.itemRefs[id] = el;
                }
              };
            },
            //判断是否有可消除的点块
            getSelection(currentArr) {
              elimination.setIndexData(currentArr)
              const isr = elimination.isrRemove() //一个元素 默认消除，多个元素要手动选择一个消除点
              console.log('可消除的点isr', isr)
              if (isr.length === 1) {
                this.removeData(currentArr, isr[0])
              } else if (isr.length > 1) {
                isr.forEach(element => {
                  const t = this.itemRefs[`i-${element[0]}-${element[1]}`]
                  t.style.color = 'red'
                  t.addEventListener('click', () => {
                    console.log('消除事件')
                    this.removeData(currentArr, element)
                  })
                });
              }
              return isr;
            },
            //消除
            /**
             * @description: 
             * @param {当前点} currentArr
             * @param {需要一起消除的点} selectedArr 
             * @return {*}
             */
            removeData(currentArr, selectedArr) {
              console.log('消除', currentArr, selectedArr)
              elimination.setElementNode(currentArr, 0)
              elimination.setElementNode(selectedArr, 0)
              this.getTwoDimensionalArrData()
              console.log('消除后', this.eliData)
              const isr = elimination.isrRemove()
              if (isr.length > 1) {
                isr.forEach(element => {
                  const t = this.itemRefs[`i-${element[0]}-${element[1]}`]
                  t.style.color = '#fff'
                  t.removeEventListener('click', () => {
                    console.log('消除事件移出')
                  })
                })
              }

              elimination.clearIsRemove()//移出
            },
            //鼠标按下
            mouseDown(e) {
              e.preventDefault()
              const [row, col] = this.getColAndRow(e.clientX, e.clientY)//传入坐标 换算 第几个块
              if (elimination.getElementNode([row, col]) === 0) return //如果是空块，则不响应
              elimination.setIndex([row, col])//设置当前点击的y轴和x轴
              //获取当前点 前后左右 是否有可消除的
              this.getSelection([row, col])
              startMousePosition = [e.clientX, e.clientY]
              //console.log('down',e)
              this.eliApp.addEventListener('mousemove', this.mouseMove)
              this.eliApp.addEventListener('mouseup', this.mouseUp)
              this.eliApp.addEventListener('mouseleave', this.mouseLeave)
            },
            //鼠标移出
            mouseLeave(e) {
              //console.log('leave')
              e.preventDefault()
              if (!elimination.getClickIndexData().length) return
              this.resetData()
            },
            //鼠标松开
            mouseUp(e) {
              // console.log('up', e.clientX, e.clientY)
              e.preventDefault()
              if (!elimination.getClickIndexData().length) {
                this.resetData()
                return
              }
              const moveObj = elimination.getMove()
              if (moveObj.moveData.length === 0) {
                this.resetData()
                return
              }
              let firstArr = []//记录第一个点的位置
              let moveData = []//移动前的值
              let newObj = []//新的位置
              for (let i = moveObj.moveData.length - 1; i >= 0; i--) {
                const v = moveObj.moveData[i]
                let data = this.getCoordinateToPosition(moveObj.move, i, e)
                let node = elimination.getElementNode(v)
                moveData.push(node)
                newObj.push(data)
                elimination.setElementNode(data, node)
                elimination.setElementNode(v, 0)
                //复位
                this.updatePosition(v, moveObj.axis, [0, 0], 111)
                if (i === 0) {
                  firstArr = data
                }
              }
              this.getTwoDimensionalArrData()
              //获取当前的位置
              //获取当前周围的点
              const isrd = this.getSelection(firstArr)
              console.log('可消除的点up-isr', isrd)
              //如果没有可以消除的点就将其还原 复位
              if (isrd.length === 0) {
                moveObj.moveData.map((v, i) => {
                  elimination.setElementNode(v, moveData[i])
                })
                newObj.map(v => {
                  elimination.setElementNode(v, 0)
                })
              }
              this.resetData()
            },
            //鼠标移动
            mouseMove(e) {
              //console.log(111, e)
              e.preventDefault()
              if (!elimination.getClickIndexData().length) return
              console.log('move后')
              const direction = this.getDirection(e)
              const moveObj = elimination.getMove()
              if (this.checkLastEle(moveObj, e)) {
                this.resetData()
                return
              } // 判断最后一个元素是否越位
              for (let i = moveObj.moveData.length - 1; i >= 0; i--) {
                this.updatePosition(moveObj.moveData[i], moveObj.axis, direction, 222)
              }
            },
            /**
             * @description: 移动位置
             * @param {位置} arr
             * @return {*}
             */
            updatePosition(arr, axis, distance = [], zIndex = 222) {
              const t = this.itemRefs[`i-${arr[0]}-${arr[1]}`]
              t.style.transform = axis === 'col' ? 'translateX(' + distance[0] + 'px)' : 'translateY(' + distance[1] + 'px)'
              t.style.zIndex = zIndex
            },
            //判断最后一个元素是否越位
            checkLastEle(moveObj, e) {
              let status = false //false 没有越位  true 有越位  默认没有越位
              //如果是最后一个元素   判断有没有越位
              if (moveObj.moveData.length === 0) return status
              const pos = this.getCoordinateToPosition(moveObj.move, moveObj.moveData.length - 1, e)
              //console.log('check', pos, elimination.getElementNode(pos))
              if (JSON.stringify(pos) === JSON.stringify(elimination.getClickIndexData())) return status //防止还未移出当前位置，就触发移出事件，误判结果
              if (pos[0] < 0 || pos[1] < 0 || pos[0] > (this.eliData.length - 1) || pos[1] > (this.eliData[0].length - 1)) {
                console.error('越位了')
                moveObj.moveData.forEach(v => {
                  this.updatePosition(v, moveObj.axis, [0, 0], 111)
                })

                status = true
              }
              if (elimination.getElementNode(pos) > 0) {
                console.error('值不为0 ,越位了')
                moveObj.moveData.forEach(v => {
                  this.updatePosition(v, moveObj.axis, [0, 0], 111)
                })
                status = true
              }
              return status
            },
            /**
             * 根据当前快 坐标换算 哪个方向的第几块 坐标 对应的 位置
             * @param {Object} move 移动的快方向
             * @param {Number} n 移动的快方向的第几块 从当前移动块之后的块 开始数
             * @param {Number} e 移动的快
             */
            getCoordinateToPosition(move, n, e) {
              //console.log('get', move, n, e)
              if (n === 0) return this.getColAndRow(e.clientX, e.clientY)
              let s = []
              if (move === elimination.getDirectionArr()[1]) {
                //left
                s = [e.clientX - n * this.balckSideLength - e.offsetX, e.clientY]
              } else if (move === elimination.getDirectionArr()[2]) {
                //right
                s = [e.clientX + n * this.balckSideLength + (this.balckSideLength - e.offsetX), e.clientY]
              } else if (move === elimination.getDirectionArr()[3]) {
                //up
                s = [e.clientX, e.clientY - n * this.balckSideLength - e.offsetY]
              } else if (move === elimination.getDirectionArr()[4]) {
                //down
                s = [e.clientX, e.clientY + n * this.balckSideLength + (this.balckSideLength - e.offsetY)]
              }
              //console.log(s, this.getColAndRow(s[0], s[1]))
              return this.getColAndRow(s[0], s[1])
            },
            getColAndRow(x, y) {
              let col = 0, row = 0
              col = Math.ceil((x - this.offsetData.start[0]) / this.balckSideLength) - 1
              row = Math.ceil((y - this.offsetData.start[1]) / this.balckSideLength) - 1
              return [row, col]
            },
            //判断移动方向
            getDirection(e) {
              let direction = ''
              const deltaX = e.clientX - startMousePosition[0]
              const deltaY = e.clientY - startMousePosition[1]
              if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                  //console.log('Moving right')
                  direction = elimination.getDirectionArr()[2]
                } else {
                  //console.log('Moving left')
                  direction = elimination.getDirectionArr()[1]
                }
              } else {
                if (deltaY > 0) {
                  //console.log('Moving down')
                  direction = elimination.getDirectionArr()[4]
                } else {
                  //console.log('Moving up')
                  direction = elimination.getDirectionArr()[3]
                }
              }
              //console.log('direction', direction)
              if (Math.abs(deltaX) >= 20 || Math.abs(deltaY) >= 20) elimination.setMove(direction)// 判断是否移动超过10px 不超过则不移动

              return [deltaX, deltaY]
            },
            //重置数据
            resetData() {
              elimination.removeClickIndexData()
              startMousePosition = []
              elimination.clearMove()
              this.eliApp.removeEventListener('mousemove', this.mouseMove)
              this.eliApp.removeEventListener('mouseup', this.mouseUp)
              this.eliApp.removeEventListener('mouseleave', this.mouseLeave)
            },
          }
        }).mount('#app')
    </script>
  </body>

</html>